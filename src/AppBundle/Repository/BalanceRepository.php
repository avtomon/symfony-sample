<?php

namespace AppBundle\Repository;

use AppBundle\Entity\Balance;
use AppBundle\SearchContext\Request\BalancesRequest\BalanceWhere;
use AppBundle\SearchContext\Request\RequestInterface;
use AppBundle\SearchContext\SearchContextDataGrabInterface;
use Doctrine\DBAL\Query\QueryBuilder;

/**
 * BalanceRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class BalanceRepository extends \Doctrine\ORM\EntityRepository implements SearchContextDataGrabInterface
{
    public const DATE_FORMAT = 'Y-m-d';

    /**
     * @param string $objectType
     * @param int $objectId
     *
     * @return Balance[]
     */
    public function findByObject(string $objectType, int $objectId) : array
    {
        return $this->findBy([
            'objectType' => $objectType,
            'objectId'   => $objectId,
        ]);
    }

    /**
     * @param RequestInterface $balanceRequest
     *
     * @return QueryBuilder
     */
    private function getNestedQuery(RequestInterface $balanceRequest) : QueryBuilder
    {
        $connection = $this->getEntityManager()->getConnection();
        $qb = new QueryBuilder($connection);
        $qb->select('object_type, object_id');
        $qb->from('billing.balance', 'b');

        /** @var BalanceWhere $where */
        $where = $balanceRequest->getWhere();
        if ($where) {
            if ($where->getObjectType() !== null) {
                $qb->andWhere('b.object_type = :object_type');
                $qb->setParameter('object_type', $where->getObjectType());
            }

            if ($where->getObjectId() !== null) {
                $qb->andWhere('b.object_id = :object_id');
                $qb->setParameter('object_id', $where->getObjectId());
            }

            if ($where->getType() !== null) {
                $qb->andWhere("b.type = ANY(string_to_array(:type, ',')::varchar[])");
                $qb->setParameter('type', implode(',', $where->getType()));
            }

            if ($where->getAccountType() !== null) {
                $qb->andWhere(
                    "b.account_type = ANY(string_to_array(:account_type, ',')::billing.balance_account_types_enum[])"
                );
                $qb->setParameter('account_type', implode(',', $where->getAccountType()));
            }

            if ($where->getCurrencyCode() !== null) {
                $qb->andWhere("b.currency_code = ANY(string_to_array(:currency_code, ',')::varchar[])");
                $qb->setParameter('currency_code', implode(',', $where->getCurrencyCode()));
            }

            if ($where->getDateFromAsDateTime() !== null) {
                $qb->andWhere('b.updated_at >= :date_from');
                $qb->setParameter(
                    'date_from',
                    $where->getDateFromAsDateTime()->format(static::DATE_FORMAT)
                );
            }

            if ($where->getDateToAsDateTime() !== null) {
                $qb->andWhere('b.updated_at < :date_to');
                $qb->setParameter(
                    'date_to',
                    $where->getDateToAsDateTime()->format(static::DATE_FORMAT)
                );
            }

            if ($where->getAmountFromAsMoney() !== null) {
                $qb->andWhere('b.amount::decimal >= :amount_from');
                $qb->setParameter(
                    'amount_from',
                    $where->getAmountFromAsMoney()->getAmount()
                );
            }

            if ($where->getAmountToAsMoney() !== null) {
                $qb->andWhere('b.amount::decimal <= :amount_to');
                $qb->setParameter(
                    'amount_to',
                    $where->getAmountToAsMoney()->getAmount()
                );
            }
        }

        $qb->groupBy('object_type, object_id');

        if ($balanceRequest->getSort()) {
            foreach ($balanceRequest->getSort() as $field => $direction) {
                if ($direction === 'DESC') {
                    $qb->addOrderBy("max($field)", $direction);
                } else {
                    $qb->addOrderBy("min($field)", $direction);
                }
            }
        }

        return $qb;
    }

    /**
     * @param RequestInterface $balanceRequest
     *
     * @return array
     *
     * @throws \Doctrine\DBAL\DBALException
     */
    public function getData(RequestInterface $balanceRequest) : array
    {
        $nestedQb = $this->getNestedQuery($balanceRequest);
        $params = $nestedQb->getParameters();

        $where = $balanceRequest->getWhere();

        $params += [
            'limit'         => $balanceRequest->getLimit(),
            'offset'        => $balanceRequest->getOffset(),
            'type'          => $where->getType() === null ? null : implode(',', $where->getType()),
            'account_type'  => $where->getAccountType() === null ? null : implode(',', $where->getAccountType()),
            'currency_code' => $where->getCurrencyCode() === null
                ? null
                : implode(',', $where->getCurrencyCode()),
            'date_from'     => $where->getDateFromAsDateTime()
                ? $where->getDateFromAsDateTime()->format(static::DATE_FORMAT)
                : null,
            'date_to'       => $where->getDateToAsDateTime()
                ? $where->getDateToAsDateTime()->format(static::DATE_FORMAT)
                : null,
            'amount_from'   => $where->getAmountFromAsMoney() ? $where->getAmountFromAsMoney()->getAmount() : null,
            'amount_to'     => $where->getAmountToAsMoney() ? $where->getAmountToAsMoney()->getAmount() : null,
        ];

        $nestedSQL = $nestedQb->getSQL() . ' LIMIT :limit OFFSET :offset';

        $sql =
            "SELECT
                b2.*
            FROM
                ($nestedSQL) b1
            LEFT JOIN
                billing.balance b2
                USING (object_type, object_id)
            WHERE
                (b2.type = ANY(string_to_array(:type, ',')::varchar[]) OR :type::varchar IS NULL)
                    AND
                (b2.updated_at >= :date_from OR :date_from::timestamp IS NULL)
                    AND
                (b2.updated_at < :date_to OR :date_to::timestamp IS NULL)
                    AND
                (b2.amount >= :amount_from OR :amount_from::decimal IS NULL OR :currency_code::varchar IS NULL)
                    AND
                (b2.amount <= :amount_to OR :amount_to::decimal IS NULL OR :currency_code::varchar IS NULL)
                    AND
                (b2.account_type = ANY(string_to_array(:account_type, ',')::billing.balance_account_types_enum[])
                    OR
                :account_type::varchar IS NULL)
                    AND
                (b2.currency_code = ANY(string_to_array(:currency_code, ',')::varchar[])
                    OR 
                :currency_code::varchar IS NULL)";

        if ($balanceRequest->getSort()) {
            $sql .= ' ORDER BY ';
            $sorts = [];
            foreach ($balanceRequest->getSort() as $field => $direction) {
                $sorts[] = "$field $direction";
            }

            $sql .= implode(', ', $sorts);
        }

        $stmt = $this->getEntityManager()->getConnection()->prepare($sql);
        $stmt->execute($params);

        return $stmt->fetchAll();
    }

    /**
     * @param RequestInterface $balanceRequest
     *
     * @return int
     *
     * @throws \Doctrine\DBAL\DBALException
     */
    public function getCount(RequestInterface $balanceRequest) : int
    {
        $nestedQb = $this->getNestedQuery($balanceRequest);
        $params = $nestedQb->getParameters();

        $sql = "SELECT count(b.object_id) FROM ({$nestedQb->getSQL()}) b";

        $stmt = $this->getEntityManager()->getConnection()->prepare($sql);
        $stmt->execute($params);

        return $stmt->fetch()['count'];
    }
}
